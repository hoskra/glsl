<!DOCTYPE html>

<html>

<head>
    <title>Example 01.05 - Control gui</title>
    <script type="text/javascript" src="libs/three.js"></script>
    <script type="text/javascript" src="libs/stats.js"></script>
    <script type="text/javascript" src="libs/dat.gui.js"></script>
    <script type="text/javascript" src="MyShaderChunks.js"></script>
    <script type="text/javascript" src="01.js"></script>
    <script type="text/javascript" src="02.js"></script>
    <script type="text/javascript" src="03.js"></script>
    <script type="text/javascript" src="04.js"></script>

    <style>
        body {
            /* set margin to 0 and overflow to hidden, to go fullscreen */
            margin: 0;
            overflow: hidden;
        }
    </style>
</head>
<body>

<div id="Stats-output">
</div>
<!-- Div which will hold the Output -->
<div id="WebGL-output">
</div>

<!-- Javascript code that runs our Three.js examples -->
<script type="text/javascript">

    const uniforms = {
      u_color_a: { value: new THREE.Color(0xff0000) },
      u_color_b: { value: new THREE.Color(0x00ffff) },
      u_time: { value: 0.0 },
      u_mouse: { value:{ x:0.0, y:0.0 }},
      u_resolution: { value:{ x:0, y:0 }}
    }

    const material = new THREE.ShaderMaterial( {
      uniforms: uniforms,
      vertexShader: vshader,
      fragmentShader: fshader,
      side: THREE.DoubleSide
    } );

    const material2 = new THREE.ShaderMaterial( {
      uniforms: uniforms,
      vertexShader: vshader2,
      fragmentShader: fshader2,
      side: THREE.DoubleSide
    } );

    const material3 = new THREE.ShaderMaterial( {
      uniforms: uniforms,
      vertexShader: vshader3,
      fragmentShader: fshader3,
      side: THREE.DoubleSide
    } );

    const material4 = new THREE.ShaderMaterial( {
      uniforms: uniforms,
      vertexShader: vshader4,
      fragmentShader: fshader4,
      side: THREE.DoubleSide
    } );

    // once everything is loaded, we run our Three.js stuff.
    function init() {

        var stats = initStats();
        let clock = new THREE.Clock();

        // create a scene, that will hold all our elements such as objects, cameras and lights.
        var scene = new THREE.Scene();

        // create a camera, which defines where we're looking at.
        var camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);

        // create a render and set the size
        var renderer = new THREE.WebGLRenderer();

        renderer.setClearColor(new THREE.Color(0xEEEEEE, 1.0));
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMapEnabled = true;

        // create the ground plane
        var planeGeometry = new THREE.PlaneGeometry(600, 600, 1, 1);
        var planeMaterial = new THREE.MeshLambertMaterial({color: 0xffffff});
        var plane = new THREE.Mesh(planeGeometry, planeMaterial);
        plane.receiveShadow = true;

        // rotate and position the plane
        plane.rotation.x = -0.5 * Math.PI;
        // plane.rotation.x = -0* Math.PI;
        plane.position.x = 0;
        plane.position.y = -100;
        plane.position.z = 0;
        // add the plane to the scene
        // scene.add(plane);

        const size = 200;
        const divisions = 100;

        const gridHelper = new THREE.GridHelper( size, divisions, 0x664513, 0x664513 );
        gridHelper.position.y -= 200;
        gridHelper.scale.x = 10;
        gridHelper.scale.y = 10;
        gridHelper.scale.z = 10;
        scene.add( gridHelper );

        // create a cube
        var cubeGeometry = new THREE.BoxGeometry(40, 40, 40, 1000);
        var cubeMaterial = new THREE.MeshLambertMaterial({color: 0xff0000});
        var cube = new THREE.Mesh(cubeGeometry, material);
        cube.castShadow = true;

        // position the cube
        cube.position.x = 20;
        cube.position.y = 0;
        cube.position.z = 0;

        scene.add(cube);

        let cube1 = new THREE.Mesh( cubeGeometry, material3 );
        let cube2 = new THREE.Mesh( cubeGeometry, material4 );


        cube1.position.x = 20;
        cube1.position.z = 20;
        cube1.position.y = 0;

        cube2.position.x = -20;
        cube2.position.z = -20;
        cube2.position.y = 0;

        scene.add( cube1 );
        scene.add( cube2 );

        // for ( let i = 0; i < cubes.size() - 1; i ++ ) {
        // }

        var sphereGeometry = new THREE.SphereGeometry(4, 50, 50);
        var sphereMaterial = new THREE.MeshLambertMaterial({color: 0x7777ff});
        var sphere = new THREE.Mesh(sphereGeometry, material2);

        // position the sphere
        sphere.position.x = 20;
        sphere.position.y = 0;
        sphere.position.z = 2;
        sphere.castShadow = true;

        // add the sphere to the scene
        scene.add(sphere);

        // position and point the camera to the center of the scene
        camera.position.x = -30;
        camera.position.y = 40;
        camera.position.z = 30;
        camera.lookAt(scene.position);

        // add subtle ambient lighting
        var ambientLight = new THREE.AmbientLight(0x0c0c0c);
        scene.add(ambientLight);

        // add spotlight for the shadows
        var spotLight = new THREE.SpotLight(0xffffff);
        spotLight.position.set(-20, 20, -10);
        // spotLight.castShadow = true;
        scene.add(spotLight);
        scene.background = new THREE.Color( 0xfaf1c3 );


        // add the output of the renderer to the html element
        document.getElementById("WebGL-output").appendChild(renderer.domElement);

        // call the render function
        var step = 0;

        var controls = new function () {
            this.rotationSpeed = 0.02;
            this.bouncingSpeed = 0.03;
        };

        var gui = new dat.GUI();
        gui.add(controls, 'rotationSpeed', 0, 0.5);
        gui.add(controls, 'bouncingSpeed', 0, 0.5);

        render();

        if ('ontouchstart' in window){
          document.addEventListener('touchmove', move);
        }else{
          window.addEventListener( 'resize', onWindowResize, false );
          document.addEventListener('mousemove', move);
        }
        function move(evt){
          uniforms.u_mouse.value.x = (evt.touches) ? evt.touches[0].clientX : evt.clientX;
          uniforms.u_mouse.value.y = (evt.touches) ? evt.touches[0].clientY : evt.clientY;
        }

        function onWindowResize( event ) {
          const aspectRatio = window.innerWidth/window.innerHeight;
          let width, height;
          if (aspectRatio>=1){
            width = 1;
            height = (window.innerHeight/window.innerWidth) * width;
          }else{
            width = aspectRatio;
            height = 1;
          }
          camera.left = -width;
          camera.right = width;
          camera.top = height;
          camera.bottom = -height;
          camera.updateProjectionMatrix();
          renderer.setSize( window.innerWidth, window.innerHeight );
          uniforms.u_resolution.value.x = window.innerWidth;
          uniforms.u_resolution.value.y = window.innerHeight;
        }

        function render() {
            stats.update();
            // rotate the cube around its axes
            // cube.rotation.x += controls.rotationSpeed;
            // cube.rotation.y += controls.rotationSpeed;
            // cube.rotation.z += controls.rotationSpeed;

            // bounce the sphere up and down
            step += controls.bouncingSpeed;
            sphere.position.x = 20 + ( 10 * (Math.cos(step)));
            sphere.position.y = 2 + ( 10 * Math.abs(Math.sin(step)));

            // render using requestAnimationFrame
            requestAnimationFrame(render);
            uniforms.u_time.value += clock.getDelta();
            renderer.render(scene, camera);
        }

        function initStats() {

            var stats = new Stats();

            stats.setMode(0); // 0: fps, 1: ms

            // Align top-left
            stats.domElement.style.position = 'absolute';
            stats.domElement.style.left = '0px';
            stats.domElement.style.top = '0px';

            document.getElementById("Stats-output").appendChild(stats.domElement);

            return stats;
        }

        this.extensions = {
          derivatives: true, // set to use derivatives
          fragDepth: true, // set to use fragment depth values
          drawBuffers: true, // set to use draw buffers
          shaderTextureLOD: true // set to use shader texture LOD
        };
    }
    window.onload = init;

</script>
</body>
</html>